\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr, float, graphicx, caption}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}

\pagestyle{fancy}
\renewcommand{\figurename}{Figura}
\renewcommand\abstractname{\textit{Abstract}}

\fancyhf{}
\fancyhead[LE,RO]{\textit{Especificación de costos}}
\fancyfoot[RE,CO]{\thepage}

\title{
	%Logo UNR
	\begin{figure}[!h]
		\centering
		\includegraphics[scale=1]{unr.png}
		\label{}
	\end{figure}
	% Pie Logo
	\normalsize
		\textsc{Universidad Nacional de Rosario}\\	
		\textsc{Facultad de Ciencias Exactas, Ingeniería y Agrimensura}\\
		\textit{Licenciatura en Ciencias de la Computación}\\
		\textit{Estructuras de datos y algoritmos II}\\
	% Título
	\vspace{30pt}
	\hrule{}
	\vspace{15pt}
	\huge
		\textbf{Especificación de costos}\\
	\vspace{15pt}
	\hrule{}
	\vspace{30pt}
	% Alumnos/docentes
	\begin{multicols}{2}
	\raggedright
		\large
			\textbf{Alumnos:}\\
		\normalsize
			CRESPO, Lisandro (C-6165/4) \\
			MISTA, Agust\'in (M-6105/1) \\
	\raggedleft
		\large
			\textbf{Docentes:}\\
		\normalsize
			JASKELIOFF, Mauro\\
			RABASEDAS, Juan Manuel\\
			SIMICH, Eugenia\\
	\end{multicols}
}

\begin{document}
\date{1 de Junio de 2015}
\maketitle

\pagebreak
\part*{Implementación con listas}
	\section*{\Large filterS}
		Para implementar la función \texttt{filterS}, consideramos la función \texttt{filter} presente en el preludio,
		y paralelizamos el llamado recursivo para mejorar el rendimiento si los predicados que \texttt{filterS} evalúa
		son costosos de calcular.
		Luego podemos considerar a \texttt{filterS} como la siguiente recurrencia:
		
		\begin{equation*}
			T\left( n \right) = T\left( n-1 \right) + f\left( n \right)
		\end{equation*}		
		
		Donde $f(n)$ es el costo de evaluar cada predicado, además del costo de las comparaciones, que consideramos constantes.
		Puede verse que en esta implementación, el paralelizar las operaciones no mejora el problema de tener que recorrer todo
		el arreglo de forma secuencial. Resolviendo la recurrencia tenemos entonces:
		
		\begin{equation*}
			W\left( filterS \oplus s \right) \in O\left( \vert s \vert + \sum_{i=0}^{\vert s\vert -1} W \left( f\left( i\right) \right) \right)
		\end{equation*}		
		
		\begin{equation*}
			S\left( filterS \oplus s \right) \in O\left( \vert s \vert + \max_{i=0}^{\vert s\vert -1}\left( S \left( f\left( i\right) \right) \right)\right)
		\end{equation*}		
\\	
\\
		Finalmente, si consideramos que $f(n) \in O(1)$ resulta:
		\\
		\\
		\begin{equation*}
			W\left( filterS \oplus s \right) \in O\left( n \right)
		\end{equation*}		
		
		\begin{equation*}
			S\left( filterS \oplus s \right) \in O\left( n \right)
		\end{equation*}		
		 	
	\section*{\Large showtS}
		Para el caso de \texttt{showtS}, la implementación mediante listas es poco eficiente dado que para poder partir la lista
		en dos mitades en el caso de que existan dos o más elementos, se necesita conocer el tamaño de la misma, lo cual resulta en un
		coste lineal tanto para el trabajo como para la profundidad. Por lo tanto:
\\
\\
		\begin{equation*}
			W\left( showtS \; s \right) \in O\left( n \right)
		\end{equation*}		
		
		\begin{equation*}
			S\left( showtS \; s \right) \in O\left( n \right)
		\end{equation*}	
\pagebreak

	\section*{\Large reduceS}
		Para analizar el costo de \texttt{reduceS}, primero debemos analizar el comportamiento de la función auxiliar \texttt{contract} que, dados una funcion binaria $\oplus$ y una secuencia s, evalúa $\oplus$ tomando pares de elementos contiguos de s, y devuelve la secuencia resultante.
		Luego, el costo de \texttt{contract} esta dado por, recorrer el arreglo s y calcular de forma paralela los costos de $\oplus$ para cada par de elementos contiguos de s (a lo sumo $\frac{\vert s\vert}{2}$ cuando $\vert s\vert$ es par).
\\
\\
		\begin{equation*}
			W \left( contract \oplus s \right) \in O \left( \vert s \vert + \sum_{i=0}^{\frac{\vert s\vert}{2}} W \left( s_{2i} \oplus s_{2i+1} \right) \right)
		\end{equation*}

		\begin{equation*}
			S \left( contract \oplus s \right) \in O \left( \vert s \vert + \max_{i=0}^{\frac{\vert s \vert}{2}} S \left( s_{2i} \oplus s_{2i+1} \right) \right)
		\end{equation*}
\\
\\		
		Luego, si consideramos $W(\oplus), S(\oplus) \in O(1)$, tenemos que:
\\
\\		
		\begin{equation*}
			W \left( contract \oplus s \right) \in O \left( \vert s \vert \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( contract \oplus s \right) \in O \left( \vert s \vert \right)
		\end{equation*}
\\
\\	
		Ahora bien, para calcular el costo de \texttt{reduceS}, vemos que éste funciona aplicando recursivamente \texttt{contract} sobre el resultado de si mismo, lo que fuerza un orden de reducción en forma de árbol completo a izquierda. Luego el costo de \texttt{reduceS} es la suma de los costos de las aplicaciones de \texttt{contract} a cada nivel del árbol de reducción, tenemos entonces:
\\
\\	
	\begin{equation*}
		W \left( reduceS \oplus s \right) \in O \left(\sum_{i=0}^{\log_2 \vert s \vert} W \left( contract \oplus s_i \right) \right) donde \; \vert s_i\vert = \frac{1}{2} \vert s_{i-1} \vert
	\end{equation*}

	\begin{equation*}
		S \left( reduceS \oplus s \right) \in O \left(\sum_{i=0}^{\log_2 \vert s \vert} S \left( contract \oplus s_i \right) \right) donde \; \vert s_i\vert = \frac{1}{2} \vert s_{i-1} \vert
	\end{equation*}
\\
\\	
	Lo que resulta:
	
	\begin{equation*}
    W \left( reduceS \oplus \; b \; s \right) \in
    O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} W \left( x \oplus y \right) \right)
	\end{equation*}

	\begin{equation*}
    S \left( reduceS \oplus \; b \; s \right) \in
    O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} S \left( x \oplus y \right) \right)
	\end{equation*}
\\
\\
		Puede verse en el resultado anterior que la profundidad del algoritmo no da lugar a una buena paralelización dado que el orden de reducción esta fijo, no pudiéndose aprovechar la mejor profundidad de \texttt{contract}.
\\
\\
				Nuevamente, si consideramos $W(\oplus), S(\oplus) \in O(1)$, tenemos que:
		
		\begin{equation*}
			W \left( reduceS \oplus s \right) \in O \left( \vert s \vert \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( reduceS \oplus s \right) \in O \left( \vert s \vert \right)
		\end{equation*}
	
\pagebreak
	\section*{\Large scanS}
	
	
\pagebreak	
\part*{Implementación con arreglos persistentes}

	\section*{\Large filterS}
		Para implementar \texttt{filterS} mediante arreglos persistentes, primero creamos una nueva secuencia mediante \texttt{tabulate} que consta de singletons en el caso de que el elemento correspondiente en la secuencia original cumple con el predicado dado, o de secuencias vacias para los elementos que no lo hacen. Luego obtenemos el resultado aplanando el resultado de \texttt{tabulate} mediante \texttt{flatten}. Luego podemos ver que el trabajo de \texttt{tabulate} resulta como la sumatoria de los trabajos de los predicados evaluados y su profundidad resulta como la máxima profundidad de los predicados, por otro lado, el trabajo de flatten resulta lineal dado que todos los elementos de la secuencia que recibe son singletons o secuencias vacías, y su profundidad resulta como el logaritmo del tamaño de la secuencia de entrada.
		Finalmente, el trabajo y la profundidad de \texttt{filterS} resultan: 
\\
\\	
	\begin{equation*}
		W \left( filterS \; f \; s \right) \in
		O \left(  \sum_{i=0}^{\vert s \vert -1} W(f \; s_i) \right)
	\end{equation*}

	\begin{equation*}
		S \left( filterS \; f \; s \right) \in
		O \left( \text{lg} \; \vert s \vert + \max_{i=0}^{\vert s \vert -1} S(f \; s_i) \right)
	\end{equation*}
\\
\\
		Si consideramos $W(f), S(f) \in O(1)$, tenemos que:
\\
\\
		\begin{equation*}
			W \left( filterS \;f \;s \right) \in O \left( \vert s \vert \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( filterS \;f \;s \right) \in O \left( lg\vert s \vert \right)
		\end{equation*}
\\

	\section*{\Large showtS}
		En el caso de showtS para arreglos persistentes, usamos esencialmente la función \texttt{subArray} de orden constante tanto en trabajo como profundidad para obtener ambos lados de la vista de árbol de la secuencia, obteniéndose:
\\
\\
		\begin{equation*}
			W\left( showtS \; s \right) \in O\left( 1 \right)
		\end{equation*}		
		
		\begin{equation*}
			S\left( showtS \; s \right) \in O\left( 1 \right)
		\end{equation*}	

\pagebreak
	\section*{\Large reduceS}
		Para implementar \texttt{reduceS} para arreglos persistentes, usamos (al igual que en la implementación con listas) una función \texttt{contract} que evalúa la función pasada entre pares contiguos de la secuencia original. Ésta funciona haciendo uso esencialmente de \texttt{tabulate}, por lo que los costos resultan análogos a los de la anterior.
\\
\\
		\begin{equation*}
			W \left( contract \oplus s \right) \in O \left( \sum_{i=0}^{\frac{\vert s \vert}{2}} W \left( s_{2i} \oplus s_{2i+1} \right) \right)
		\end{equation*}

		\begin{equation*}
		S \left( contract \oplus s \right) \in O \left( \max_{i=0}^{\frac{\vert s \vert}{2}} S \left( s_{2i} \oplus s_{2i+1} \right) \right)
		\end{equation*}
\\
\\
		Si consideramos $W(\oplus), S(\oplus) \in O(1)$, tenemos que:
\\
\\		
		\begin{equation*}
			W \left( contract \oplus \; s \right) \in O \left( \frac{\vert s \vert}{2} \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( contract \oplus s \right) \in O \left( 1 \right)
		\end{equation*}
\\
\\	
		Luego, \texttt{reduceS} llama recursivamente a \texttt{contract} con una secuencia de la mitad del tamaño de la secuencia del llamado anterior, por lo que podemos plantear la misma relación entre \texttt{reduceS} y \texttt{contract} del caso de listas:
\\
\\	
	\begin{equation*}
		W \left( reduceS \oplus s \right) \in O \left(\sum_{i=0}^{\log_2 \vert s \vert} W \left( contract \oplus s_i \right) \right) donde \; \vert s_i\vert = \frac{1}{2} \vert s_{i-1} \vert
	\end{equation*}

	\begin{equation*}
		S \left( reduceS \oplus s \right) \in O \left(\sum_{i=0}^{\log_2 \vert s \vert} S \left( contract \oplus s_i \right) \right) donde \; \vert s_i\vert = \frac{1}{2} \vert s_{i-1} \vert
	\end{equation*}
\\
\\
	Pero en esta implementación contamos con una función \texttt{contract} mucho más paralelizable que en la versión de listas, resultando en una profundidad que a lo sumo puede ser tan mala como llamar h veces a la peor evaluación de $\oplus$, donde h es la altura del árbol. El trabajo de la misma resulta similar al de la versión de listas, puesto que recorrer los elementos de cada nivel del árbol tiene un coste lineal y además debemos sumar todos los trabajos de las evaluaciones de $\oplus$.
\\
\\
		\begin{equation*}
			W \left( reduceS \oplus e \; s \right) \in
			O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} W \left( x \oplus y \right) \right)
		\end{equation*}

		\begin{equation*}
			S \left( reduceS \oplus e \; s \right) \in
			O \left( \text{lg} \; \vert s \vert \; \max_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} S \left( x \oplus y \right) \right)
		\end{equation*}
\\
\\
		Además, si consideramos $W(\oplus), S(\oplus) \in O(1)$, resultan:
	
		\begin{equation*}
			W \left( reduceS \oplus \; e \; s \right) \in O \left( \vert s \vert \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( reduceS \oplus \; e \; s \right) \in O \left( lg \vert s \vert \right)
		\end{equation*}

\pagebreak
	\section*{\Large scanS}
		Para el caso de la implementación de arreglos persistentes de \texttt{scanS}, se hace uso de las funciones \texttt{contract}(analizada para \texttt{reduceS}) y \texttt{combine}, la cual combina dos secuencias mediante un operador $\oplus$, sabiendo que una de ellas es el resultado de aplicar recursivamente \texttt{contract} y \texttt{scanS} a la otra, con lo que obtenemos resultados parciales de \texttt{scanS} en cada llamada a \texttt{combine}.
	\texttt{combine} hace uso esencialmente de \texttt{tabulate} que crea una secuencia mediante una función que evalúa si el indice actual es par o no, y cuyo costo es a lo sumo evaluar $\oplus$, por lo que el costo de combine dependen únicamente de el costo de $\oplus$, resultando:
\\
\\
\begin{equation*}
    W \left( combine \oplus s \; partial \right) \in
    O \left( \sum_{i=1}^{\frac{\vert s \vert}{2}} W \left( partial_{i} \oplus s_{2i-1} \right) \right)
\end{equation*}

\begin{equation*}
    S \left( combine \oplus s \; partial \right) \in
    O \left( \max_{i=1}^{\frac{\vert s \vert}{2}} S \left( partial_{i} \oplus s_{2i-1} \right) \right)
\end{equation*}
\\
\\
		Si consideramos $W(\oplus), S(\oplus) \in O(1)$, tenemos que:
\\
\\		
		\begin{equation*}
			W \left( combine \oplus s \; partial \right) \in O \left( \frac{\vert s \vert}{2} \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( combine \oplus s \; partial \right) \in O \left( 1 \right)
		\end{equation*}
\\
\\	
		Luego, \texttt{scanS} llama recursivamente a \texttt{contract} y ejecuta \texttt{combine} en el primer elemento de la tupla obtenida para actualizar los valores de la secuencia de reducción.
		En cada llamado recursivo, \texttt{contract} recibe una secuencia de tamaño igual a la mitad de la del llamado recursivo anteror, por lo que el costo de \texttt{scanS} resulta similar al de \texttt{reduceS}
\\
\\
		\begin{equation*}
			W \left( scanS \oplus e \; s \right) \in
			O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_s(\oplus,b,s)} W \left( x \oplus y \right) \right)
		\end{equation*}

		\begin{equation*}
			S \left( scanS \oplus e \; s \right) \in
			O \left( \text{lg} \; \vert s \vert \; \max_{(x \oplus y) \in \mathcal{O}_s(\oplus,b,s)} S \left( x \oplus y \right) \right)
		\end{equation*}
\\
\\		
		Finalmente, si consideramos $W(\oplus), S(\oplus) \in O(1)$, tenemos que:
\\
\\		
		\begin{equation*}
			W \left( scanS \oplus e \; s  \right) \in O \left( \vert s \vert \right)
		\end{equation*}
		
		\begin{equation*}
			S \left( scanS \oplus e \; s  \right) \in O \left( lg\vert s \vert \right)
		\end{equation*}
\pagebreak
\\
\vspace{\fill}
\begin{multicols}{2}
	\hrule
	\vspace{5pt}
	CRESPO, Lisandro \\
	\linebreak

	\hrule
	\vspace{5pt}
	MISTA, Agustín \\
\end{multicols}

\end{document}
